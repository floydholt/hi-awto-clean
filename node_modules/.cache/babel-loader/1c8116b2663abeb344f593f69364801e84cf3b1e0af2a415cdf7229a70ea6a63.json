{"ast":null,"code":"// src/firebase/messages.js\nimport { collection, addDoc, doc, getDoc, getDocs, updateDoc, query, where, orderBy, serverTimestamp, writeBatch } from \"firebase/firestore\";\nimport { db } from \"./config\";\nconst THREADS_COL = \"threads\";\n\n// ---------------------------------------------\n// Single thread by id\n// ---------------------------------------------\nexport async function getThread(threadId) {\n  if (!threadId) return null;\n  const ref = doc(db, THREADS_COL, threadId);\n  const snap = await getDoc(ref);\n  return snap.exists() ? {\n    id: snap.id,\n    ...snap.data()\n  } : null;\n}\n\n// ---------------------------------------------\n// Threads for a specific user (inbox)\n// ---------------------------------------------\nexport async function getUserThreads(userId) {\n  if (!userId) return [];\n  const q = query(collection(db, THREADS_COL), where(\"participants\", \"array-contains\", userId), orderBy(\"updatedAt\", \"desc\"));\n  const snap = await getDocs(q);\n  return snap.docs.map(d => ({\n    id: d.id,\n    ...d.data()\n  }));\n}\n\n// ---------------------------------------------\n// ALL threads (admin inbox)\n// ---------------------------------------------\nexport async function getAllThreads() {\n  const q = query(collection(db, THREADS_COL), orderBy(\"updatedAt\", \"desc\"));\n  const snap = await getDocs(q);\n  return snap.docs.map(d => ({\n    id: d.id,\n    ...d.data()\n  }));\n}\n\n// ---------------------------------------------\n// Messages in a thread (non-realtime helper)\n// ---------------------------------------------\nexport async function getThreadMessages(threadId) {\n  if (!threadId) return [];\n  const msgsRef = collection(db, `${THREADS_COL}/${threadId}/messages`);\n  const q = query(msgsRef, orderBy(\"createdAt\", \"asc\"));\n  const snap = await getDocs(q);\n  return snap.docs.map(d => ({\n    id: d.id,\n    ...d.data()\n  }));\n}\n\n// ---------------------------------------------\n// Send a message in an existing thread\n// message: { text, senderId, senderName, attachments?, readBy? }\n// ---------------------------------------------\nexport async function sendMessage(threadId, message) {\n  if (!threadId) throw new Error(\"threadId is required\");\n  const threadRef = doc(db, THREADS_COL, threadId);\n  const msgsRef = collection(threadRef, \"messages\");\n  const now = serverTimestamp();\n  await addDoc(msgsRef, {\n    ...message,\n    pinned: message.pinned || false,\n    createdAt: now,\n    updatedAt: now\n  });\n  await updateDoc(threadRef, {\n    updatedAt: now,\n    lastMessage: message.text || \"[Attachment]\",\n    lastSenderId: message.senderId || null\n  });\n}\n\n// ---------------------------------------------\n// Typing indicator\n// ---------------------------------------------\nexport async function setThreadTyping(threadId, userId, isTyping) {\n  if (!threadId || !userId) return;\n  const threadRef = doc(db, THREADS_COL, threadId);\n  await updateDoc(threadRef, {\n    [`typing.${userId}`]: !!isTyping\n  });\n}\n\n// ---------------------------------------------\n// Mark messages as read\n// ---------------------------------------------\nexport async function markThreadMessagesRead(threadId, userId) {\n  if (!threadId || !userId) return;\n  const msgsRef = collection(db, `${THREADS_COL}/${threadId}/messages`);\n\n  // Simple filter; adjust if needed based on your data\n  const q = query(msgsRef, where(\"readBy\", \"not-in\", [[userId]]));\n  const snap = await getDocs(q);\n  if (snap.empty) return;\n  const batch = writeBatch(db);\n  snap.docs.forEach(docSnap => {\n    const data = docSnap.data();\n    const readBy = Array.isArray(data.readBy) ? data.readBy : [];\n    if (!readBy.includes(userId)) {\n      batch.update(docSnap.ref, {\n        readBy: [...readBy, userId]\n      });\n    }\n  });\n  await batch.commit();\n}\n\n// ---------------------------------------------\n// Pin / unpin a message\n// ---------------------------------------------\nexport async function pinMessage(threadId, messageId, value) {\n  if (!threadId || !messageId) return;\n  const msgRef = doc(db, `${THREADS_COL}/${threadId}/messages/${messageId}`);\n  await updateDoc(msgRef, {\n    pinned: !!value,\n    updatedAt: serverTimestamp()\n  });\n}","map":{"version":3,"names":["collection","addDoc","doc","getDoc","getDocs","updateDoc","query","where","orderBy","serverTimestamp","writeBatch","db","THREADS_COL","getThread","threadId","ref","snap","exists","id","data","getUserThreads","userId","q","docs","map","d","getAllThreads","getThreadMessages","msgsRef","sendMessage","message","Error","threadRef","now","pinned","createdAt","updatedAt","lastMessage","text","lastSenderId","senderId","setThreadTyping","isTyping","markThreadMessagesRead","empty","batch","forEach","docSnap","readBy","Array","isArray","includes","update","commit","pinMessage","messageId","value","msgRef"],"sources":["C:/Users/Floyd/Desktop/Websites/HIAWTO/hi-awto-clean/src/firebase/messages.js"],"sourcesContent":["// src/firebase/messages.js\r\nimport {\r\n  collection,\r\n  addDoc,\r\n  doc,\r\n  getDoc,\r\n  getDocs,\r\n  updateDoc,\r\n  query,\r\n  where,\r\n  orderBy,\r\n  serverTimestamp,\r\n  writeBatch,\r\n} from \"firebase/firestore\";\r\nimport { db } from \"./config\";\r\n\r\nconst THREADS_COL = \"threads\";\r\n\r\n// ---------------------------------------------\r\n// Single thread by id\r\n// ---------------------------------------------\r\nexport async function getThread(threadId) {\r\n  if (!threadId) return null;\r\n  const ref = doc(db, THREADS_COL, threadId);\r\n  const snap = await getDoc(ref);\r\n  return snap.exists() ? { id: snap.id, ...snap.data() } : null;\r\n}\r\n\r\n// ---------------------------------------------\r\n// Threads for a specific user (inbox)\r\n// ---------------------------------------------\r\nexport async function getUserThreads(userId) {\r\n  if (!userId) return [];\r\n  const q = query(\r\n    collection(db, THREADS_COL),\r\n    where(\"participants\", \"array-contains\", userId),\r\n    orderBy(\"updatedAt\", \"desc\")\r\n  );\r\n  const snap = await getDocs(q);\r\n  return snap.docs.map((d) => ({ id: d.id, ...d.data() }));\r\n}\r\n\r\n// ---------------------------------------------\r\n// ALL threads (admin inbox)\r\n// ---------------------------------------------\r\nexport async function getAllThreads() {\r\n  const q = query(\r\n    collection(db, THREADS_COL),\r\n    orderBy(\"updatedAt\", \"desc\")\r\n  );\r\n  const snap = await getDocs(q);\r\n  return snap.docs.map((d) => ({ id: d.id, ...d.data() }));\r\n}\r\n\r\n// ---------------------------------------------\r\n// Messages in a thread (non-realtime helper)\r\n// ---------------------------------------------\r\nexport async function getThreadMessages(threadId) {\r\n  if (!threadId) return [];\r\n  const msgsRef = collection(db, `${THREADS_COL}/${threadId}/messages`);\r\n  const q = query(msgsRef, orderBy(\"createdAt\", \"asc\"));\r\n  const snap = await getDocs(q);\r\n  return snap.docs.map((d) => ({ id: d.id, ...d.data() }));\r\n}\r\n\r\n// ---------------------------------------------\r\n// Send a message in an existing thread\r\n// message: { text, senderId, senderName, attachments?, readBy? }\r\n// ---------------------------------------------\r\nexport async function sendMessage(threadId, message) {\r\n  if (!threadId) throw new Error(\"threadId is required\");\r\n\r\n  const threadRef = doc(db, THREADS_COL, threadId);\r\n  const msgsRef = collection(threadRef, \"messages\");\r\n  const now = serverTimestamp();\r\n\r\n  await addDoc(msgsRef, {\r\n    ...message,\r\n    pinned: message.pinned || false,\r\n    createdAt: now,\r\n    updatedAt: now,\r\n  });\r\n\r\n  await updateDoc(threadRef, {\r\n    updatedAt: now,\r\n    lastMessage: message.text || \"[Attachment]\",\r\n    lastSenderId: message.senderId || null,\r\n  });\r\n}\r\n\r\n// ---------------------------------------------\r\n// Typing indicator\r\n// ---------------------------------------------\r\nexport async function setThreadTyping(threadId, userId, isTyping) {\r\n  if (!threadId || !userId) return;\r\n  const threadRef = doc(db, THREADS_COL, threadId);\r\n\r\n  await updateDoc(threadRef, {\r\n    [`typing.${userId}`]: !!isTyping,\r\n  });\r\n}\r\n\r\n// ---------------------------------------------\r\n// Mark messages as read\r\n// ---------------------------------------------\r\nexport async function markThreadMessagesRead(threadId, userId) {\r\n  if (!threadId || !userId) return;\r\n\r\n  const msgsRef = collection(db, `${THREADS_COL}/${threadId}/messages`);\r\n\r\n  // Simple filter; adjust if needed based on your data\r\n  const q = query(\r\n    msgsRef,\r\n    where(\"readBy\", \"not-in\", [[userId]])\r\n  );\r\n\r\n  const snap = await getDocs(q);\r\n  if (snap.empty) return;\r\n\r\n  const batch = writeBatch(db);\r\n\r\n  snap.docs.forEach((docSnap) => {\r\n    const data = docSnap.data();\r\n    const readBy = Array.isArray(data.readBy) ? data.readBy : [];\r\n    if (!readBy.includes(userId)) {\r\n      batch.update(docSnap.ref, {\r\n        readBy: [...readBy, userId],\r\n      });\r\n    }\r\n  });\r\n\r\n  await batch.commit();\r\n}\r\n\r\n// ---------------------------------------------\r\n// Pin / unpin a message\r\n// ---------------------------------------------\r\nexport async function pinMessage(threadId, messageId, value) {\r\n  if (!threadId || !messageId) return;\r\n\r\n  const msgRef = doc(\r\n    db,\r\n    `${THREADS_COL}/${threadId}/messages/${messageId}`\r\n  );\r\n\r\n  await updateDoc(msgRef, {\r\n    pinned: !!value,\r\n    updatedAt: serverTimestamp(),\r\n  });\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}