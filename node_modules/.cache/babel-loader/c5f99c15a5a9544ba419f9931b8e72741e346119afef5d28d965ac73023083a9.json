{"ast":null,"code":"// src/firebase/messages.js\nimport { collection, addDoc, doc, getDoc, getDocs, updateDoc, query, where, orderBy, serverTimestamp, writeBatch } from \"firebase/firestore\";\nimport { db } from \"./config\";\nconst THREADS_COL = \"threads\";\n\n// Get a single thread by id\nexport async function getThread(threadId) {\n  const ref = doc(db, THREADS_COL, threadId);\n  const snap = await getDoc(ref);\n  return snap.exists() ? {\n    id: snap.id,\n    ...snap.data()\n  } : null;\n}\n\n// Get threads for a user (inbox)\nexport async function getUserThreads(userId) {\n  const q = query(collection(db, THREADS_COL), where(\"participants\", \"array-contains\", userId), orderBy(\"updatedAt\", \"desc\"));\n  const snap = await getDocs(q);\n  return snap.docs.map(d => ({\n    id: d.id,\n    ...d.data()\n  }));\n}\n\n// Send a message in an existing thread\nexport async function sendMessage(threadId, message) {\n  const threadRef = doc(db, THREADS_COL, threadId);\n  const msgsRef = collection(threadRef, \"messages\");\n  const now = serverTimestamp();\n\n  // message shape: { text, senderId, senderName, attachments?, readBy? }\n  await addDoc(msgsRef, {\n    ...message,\n    pinned: message.pinned || false,\n    createdAt: now,\n    updatedAt: now\n  });\n  await updateDoc(threadRef, {\n    updatedAt: now,\n    lastMessage: message.text || \"[Attachment]\",\n    lastSenderId: message.senderId || null\n  });\n}\n\n// Typing indicator for this thread\nexport async function setThreadTyping(threadId, userId, isTyping) {\n  if (!threadId || !userId) return;\n  const threadRef = doc(db, THREADS_COL, threadId);\n  await updateDoc(threadRef, {\n    [`typing.${userId}`]: !!isTyping\n  });\n}\n\n// Mark messages in a thread as read by a user\nexport async function markThreadMessagesRead(threadId, userId) {\n  if (!threadId || !userId) return;\n  const msgsRef = collection(db, `${THREADS_COL}/${threadId}/messages`);\n  const q = query(msgsRef, where(\"readBy\", \"not-in\", [[userId]]) // simple filter; may be adjusted if needed\n  );\n  const snap = await getDocs(q);\n  if (snap.empty) return;\n  const batch = writeBatch(db);\n  snap.docs.forEach(docSnap => {\n    const data = docSnap.data();\n    const readBy = Array.isArray(data.readBy) ? data.readBy : [];\n    if (!readBy.includes(userId)) {\n      batch.update(docSnap.ref, {\n        readBy: [...readBy, userId]\n      });\n    }\n  });\n  await batch.commit();\n}\n\n// ⭐ NEW: Pin / unpin a message\nexport async function pinMessage(threadId, messageId, value) {\n  if (!threadId || !messageId) return;\n  const msgRef = doc(db, `${THREADS_COL}/${threadId}/messages/${messageId}`);\n  await updateDoc(msgRef, {\n    pinned: !!value,\n    updatedAt: serverTimestamp()\n  });\n}","map":{"version":3,"names":["collection","addDoc","doc","getDoc","getDocs","updateDoc","query","where","orderBy","serverTimestamp","writeBatch","db","THREADS_COL","getThread","threadId","ref","snap","exists","id","data","getUserThreads","userId","q","docs","map","d","sendMessage","message","threadRef","msgsRef","now","pinned","createdAt","updatedAt","lastMessage","text","lastSenderId","senderId","setThreadTyping","isTyping","markThreadMessagesRead","empty","batch","forEach","docSnap","readBy","Array","isArray","includes","update","commit","pinMessage","messageId","value","msgRef"],"sources":["C:/Users/Floyd/Desktop/Websites/HIAWTO/hi-awto-clean/src/firebase/messages.js"],"sourcesContent":["// src/firebase/messages.js\r\nimport {\r\n  collection,\r\n  addDoc,\r\n  doc,\r\n  getDoc,\r\n  getDocs,\r\n  updateDoc,\r\n  query,\r\n  where,\r\n  orderBy,\r\n  serverTimestamp,\r\n  writeBatch,\r\n} from \"firebase/firestore\";\r\nimport { db } from \"./config\";\r\n\r\nconst THREADS_COL = \"threads\";\r\n\r\n// Get a single thread by id\r\nexport async function getThread(threadId) {\r\n  const ref = doc(db, THREADS_COL, threadId);\r\n  const snap = await getDoc(ref);\r\n  return snap.exists() ? { id: snap.id, ...snap.data() } : null;\r\n}\r\n\r\n// Get threads for a user (inbox)\r\nexport async function getUserThreads(userId) {\r\n  const q = query(\r\n    collection(db, THREADS_COL),\r\n    where(\"participants\", \"array-contains\", userId),\r\n    orderBy(\"updatedAt\", \"desc\")\r\n  );\r\n  const snap = await getDocs(q);\r\n  return snap.docs.map((d) => ({ id: d.id, ...d.data() }));\r\n}\r\n\r\n// Send a message in an existing thread\r\nexport async function sendMessage(threadId, message) {\r\n  const threadRef = doc(db, THREADS_COL, threadId);\r\n  const msgsRef = collection(threadRef, \"messages\");\r\n  const now = serverTimestamp();\r\n\r\n  // message shape: { text, senderId, senderName, attachments?, readBy? }\r\n  await addDoc(msgsRef, {\r\n    ...message,\r\n    pinned: message.pinned || false,\r\n    createdAt: now,\r\n    updatedAt: now,\r\n  });\r\n\r\n  await updateDoc(threadRef, {\r\n    updatedAt: now,\r\n    lastMessage: message.text || \"[Attachment]\",\r\n    lastSenderId: message.senderId || null,\r\n  });\r\n}\r\n\r\n// Typing indicator for this thread\r\nexport async function setThreadTyping(threadId, userId, isTyping) {\r\n  if (!threadId || !userId) return;\r\n  const threadRef = doc(db, THREADS_COL, threadId);\r\n\r\n  await updateDoc(threadRef, {\r\n    [`typing.${userId}`]: !!isTyping,\r\n  });\r\n}\r\n\r\n// Mark messages in a thread as read by a user\r\nexport async function markThreadMessagesRead(threadId, userId) {\r\n  if (!threadId || !userId) return;\r\n  const msgsRef = collection(db, `${THREADS_COL}/${threadId}/messages`);\r\n\r\n  const q = query(\r\n    msgsRef,\r\n    where(\"readBy\", \"not-in\", [[userId]]) // simple filter; may be adjusted if needed\r\n  );\r\n\r\n  const snap = await getDocs(q);\r\n  if (snap.empty) return;\r\n\r\n  const batch = writeBatch(db);\r\n  snap.docs.forEach((docSnap) => {\r\n    const data = docSnap.data();\r\n    const readBy = Array.isArray(data.readBy) ? data.readBy : [];\r\n    if (!readBy.includes(userId)) {\r\n      batch.update(docSnap.ref, {\r\n        readBy: [...readBy, userId],\r\n      });\r\n    }\r\n  });\r\n\r\n  await batch.commit();\r\n}\r\n\r\n// ⭐ NEW: Pin / unpin a message\r\nexport async function pinMessage(threadId, messageId, value) {\r\n  if (!threadId || !messageId) return;\r\n  const msgRef = doc(db, `${THREADS_COL}/${threadId}/messages/${messageId}`);\r\n\r\n  await updateDoc(msgRef, {\r\n    pinned: !!value,\r\n    updatedAt: serverTimestamp(),\r\n  });\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}