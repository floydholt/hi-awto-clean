// src/utils/exportFraudPdf.js
import jsPDF from "jspdf";
import "jspdf-autotable";
import { encryptPdf, downloadEncryptedPdf } from "./encryptPdf.js";

/**
 * Internal helper – build a jsPDF instance.
 *
 * mode = "internal" | "public"
 *  - internal: full details + flags + explanations + CONFIDENTIAL watermark
 *  - public: redacted, no flags/explanations, no CONFIDENTIAL watermark
 */
function buildFraudPdfDoc(
  {
    fraudEvents = [],
    listings = [],
    rangeLabel = "",
  },
  mode = "internal"
) {
  const doc = new jsPDF({
    orientation: "portrait",
    unit: "pt",
    format: "a4",
  });

  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();

  const brandBlue = "#2563EB";
  const dangerRed = "#DC2626";
  const amber = "#F59E0B";
  const slate = "#64748B";

  const isInternal = mode === "internal";
  const isPublic = mode === "public";

  // ---------------------------
  // GLOBAL HEADER / FOOTER
  // ---------------------------
  const addHeader = () => {
    doc.setFillColor(37, 99, 235);
    doc.rect(0, 0, pageWidth, 48, "F");

    doc.setFont("helvetica", "bold");
    doc.setFontSize(18);
    doc.setTextColor("#FFFFFF");

    const titleSuffix = isPublic ? "· Public Summary" : "· Fraud Intelligence Report";
    doc.text(`HI-AWTO ${titleSuffix}`, 32, 30);
  };

  const addFooter = () => {
    const footerY = pageHeight - 24;
    doc.setFont("helvetica", "normal");
    doc.setFontSize(9);
    doc.setTextColor(slate);

    const footerText = isPublic
      ? "Public summary · Generated by HI-AWTO · Powered by Gemini AI"
      : "Powered by Gemini AI · Internal fraud analytics only · Not a formal underwriting decision";

    doc.text(footerText, 32, footerY);

    const pageCount = doc.getNumberOfPages();
    doc.text(`Page ${pageCount}`, pageWidth - 60, footerY);
  };

  const addConfidentialWatermark = (text = "CONFIDENTIAL") => {
    if (!isInternal) return; // never show for public mode

    doc.saveGraphicsState();
    doc.setTextColor(220, 38, 38);
    doc.setFontSize(60);
    doc.setFont("helvetica", "bold");

    // @ts-ignore – jspdf GState plugin
    if (doc.GState) {
      // @ts-ignore
      doc.setGState(doc.GState({ opacity: 0.08 }));
    }

    doc.text(text, pageWidth / 2, pageHeight / 2, {
      angle: 45,
      align: "center",
    });
    doc.restoreGraphicsState();
  };

  const hasHighRisk =
    fraudEvents.some((e) => e.riskLevel === "high") ||
    listings.some((l) => l?.aiFraud?.riskLevel === "high");

  // ---------------------------
  // COVER PAGE
  // ---------------------------
  addHeader();

  // Title
  doc.setFont("helvetica", "bold");
  doc.setFontSize(24);
  doc.setTextColor("#0F172A");
  doc.text(
    isPublic ? "Fraud Risk Public Overview" : "Fraud Risk Overview",
    32,
    96
  );

  doc.setFont("helvetica", "normal");
  doc.setFontSize(11);
  doc.setTextColor(slate);

  const now = new Date();
  const generatedAt = now.toLocaleString();

  doc.text(`Generated: ${generatedAt}`, 32, 120);
  if (rangeLabel) {
    doc.text(`Time Range: ${rangeLabel}`, 32, 136);
  }

  const totalEvents = fraudEvents.length;
  const highEvents = fraudEvents.filter((e) => e.riskLevel === "high").length;
  const mediumEvents = fraudEvents.filter((e) => e.riskLevel === "medium").length;
  const lowEvents = fraudEvents.filter((e) => e.riskLevel === "low").length;

  const avgScore =
    totalEvents > 0
      ? Math.round(
          fraudEvents.reduce((sum, e) => sum + (e.score || 0), 0) / totalEvents
        )
      : 0;

  doc.setFontSize(12);
  doc.setTextColor("#111827");

  let y = 180;
  doc.text(`Total fraud events: ${totalEvents}`, 32, y);
  y += 20;
  doc.text(`Average fraud score: ${avgScore}`, 32, y);
  y += 20;
  doc.setTextColor(dangerRed);
  doc.text(`High risk events: ${highEvents}`, 32, y);
  y += 20;
  doc.setTextColor(amber);
  doc.text(`Medium risk events: ${mediumEvents}`, 32, y);
  y += 20;
  doc.setTextColor("#16A34A");
  doc.text(`Low risk events: ${lowEvents}`, 32, y);

  // Summary
  y += 40;
  doc.setTextColor("#0F172A");
  doc.setFontSize(12);
  doc.setFont("helvetica", "bold");
  doc.text("Summary", 32, y);
  y += 16;
  doc.setFont("helvetica", "normal");
  doc.setFontSize(10);
  doc.setTextColor(slate);

  let summaryText;
  if (totalEvents === 0) {
    summaryText = isPublic
      ? "No recorded AI fraud risk activity for the selected time range."
      : "No recorded AI fraud events for the selected time range.";
  } else if (isPublic) {
    summaryText =
      "This public summary provides an aggregate view of AI-estimated fraud risk across HI-AWTO listings. " +
      "It does not expose internal flags or detailed explanations and should not be treated as a formal underwriting decision.";
  } else {
    summaryText =
      "This report summarizes AI-driven fraud scores and risk flags across HI-AWTO listings. High scores indicate " +
      "listings that diverge from typical patterns in price, description, or media. Use this report to prioritize " +
      "manual review and confirm whether listings should be approved, corrected, or removed.";
  }

  const summaryLines = doc.splitTextToSize(summaryText, pageWidth - 64);
  doc.text(summaryLines, 32, y);

  if (isInternal && hasHighRisk) {
    addConfidentialWatermark("CONFIDENTIAL");
  }

  addFooter();

  // ---------------------------
  // GLOBAL FRAUD EVENTS TABLE
  // ---------------------------
  if (fraudEvents.length > 0) {
    doc.addPage();
    addHeader();
    if (isInternal && hasHighRisk) addConfidentialWatermark("CONFIDENTIAL");

    doc.setFont("helvetica", "bold");
    doc.setFontSize(14);
    doc.setTextColor("#0F172A");
    doc.text(
      isPublic ? "Fraud Events Summary" : "Fraud Events Timeline",
      32,
      80
    );

    doc.setFontSize(10);
    doc.setFont("helvetica", "normal");
    doc.setTextColor(slate);
    doc.text(
      isPublic
        ? "Aggregate risk overview per listing and time. Sensitive internal flags and explanations are redacted."
        : "Each row represents an AI-generated fraud score for a listing at a given time.",
      32,
      100
    );

    let head;
    let body;

    if (isPublic) {
      head = [["Date", "Listing ID", "Score", "Risk"]];
      body = fraudEvents.map((e) => [
        e.timestamp ? new Date(e.timestamp).toLocaleString() : "",
        e.listingId || "—",
        e.score ?? "—",
        e.riskLevel || "—",
      ]);
    } else {
      head = [["Date", "Listing ID", "Score", "Risk", "Flags (top 3)"]];
      body = fraudEvents.map((e) => {
        const dateStr = e.timestamp
          ? new Date(e.timestamp).toLocaleString()
          : "";
        return [
          dateStr,
          e.listingId || "—",
          e.score ?? "—",
          e.riskLevel || "—",
          (e.flags || []).slice(0, 3).join(", "),
        ];
      });
    }

    doc.autoTable({
      head,
      body,
      startY: 120,
      styles: {
        fontSize: 8,
      },
      headStyles: {
        fillColor: [37, 99, 235],
        textColor: 255,
      },
      alternateRowStyles: {
        fillColor: [248, 250, 252],
      },
      margin: { left: 32, right: 32 },
      didDrawPage: () => {
        addHeader();
        if (isInternal && hasHighRisk) addConfidentialWatermark("CONFIDENTIAL");
        addFooter();
      },
    });
  }

  // ---------------------------
  // PER-LISTING SHEETS (internal only)
  // ---------------------------
  if (isInternal) {
    const eventsByListing = fraudEvents.reduce((acc, e) => {
      const id = e.listingId || "unknown";
      if (!acc[id]) acc[id] = [];
      acc[id].push(e);
      return acc;
    }, /** @type {Record<string, any[]>} */ ({}));

    const listingMap = listings.reduce((acc, l) => {
      acc[l.id] = l;
      return acc;
    }, /** @type {Record<string, any>} */ ({}));

    Object.keys(eventsByListing).forEach((listingId) => {
      const eventsForListing = eventsByListing[listingId] || [];
      const listing = listingMap[listingId];

      doc.addPage();
      addHeader();
      const listingHasHigh = eventsForListing.some(
        (e) => e.riskLevel === "high"
      );
      if (listingHasHigh) addConfidentialWatermark("CONFIDENTIAL");
      else if (hasHighRisk) addConfidentialWatermark("INTERNAL USE ONLY");

      let yPos = 80;

      // Title
      doc.setFont("helvetica", "bold");
      doc.setFontSize(14);
      doc.setTextColor("#0F172A");
      doc.text(
        `Listing Fraud Signature: ${listing?.title || listingId}`,
        32,
        yPos
      );
      yPos += 18;

      // Basic listing info
      doc.setFont("helvetica", "normal");
      doc.setFontSize(10);
      doc.setTextColor(slate);

      const addressLine = listing?.address || "Address: —";
      const priceLine = listing?.price
        ? `Price: $${Number(listing.price).toLocaleString()}`
        : "Price: —";

      doc.text(addressLine, 32, yPos);
      yPos += 14;
      doc.text(priceLine, 32, yPos);
      yPos += 18;

      // AI pricing snapshot
      if (listing?.aiPricing) {
        const p = listing.aiPricing;
        const pricingLines = [
          `AI suggested price: $${Number(p.estimate).toLocaleString()} (range $${Number(
            p.low
          ).toLocaleString()} – $${Number(p.high).toLocaleString()})`,
          `Suggested down payment: $${Number(p.downPayment).toLocaleString()}`,
          `Confidence: ${p.confidence || "—"}`,
        ];
        doc.setTextColor("#111827");
        doc.text("AI Pricing Insight:", 32, yPos);
        yPos += 14;
        doc.setTextColor(slate);
        doc.text(
          doc.splitTextToSize(pricingLines.join(" · "), pageWidth - 64),
          32,
          yPos
        );
        yPos += 26;
      }

      // AI fraud snapshot
      if (listing?.aiFraud) {
        const f = listing.aiFraud;
        doc.setTextColor("#111827");
        doc.text("AI Fraud Snapshot:", 32, yPos);
        yPos += 14;
        doc.setTextColor(slate);
        const fraudLines = [
          `Score: ${f.score ?? "—"} (${f.riskLevel ?? "unknown"} risk)`,
          `Flags: ${(f.flags || []).join(", ") || "—"}`,
          f.explanation || "",
        ].filter(Boolean);
        const splitted = doc.splitTextToSize(
          fraudLines.join("  •  "),
          pageWidth - 64
        );
        doc.text(splitted, 32, yPos);
        yPos += 26;
      }

      // Table of events for this listing
      const rows = eventsForListing.map((e) => [
        e.timestamp ? new Date(e.timestamp).toLocaleString() : "",
        e.score ?? "—",
        e.riskLevel || "—",
        (e.flags || []).slice(0, 3).join(", "),
      ]);

      doc.autoTable({
        head: [["Date", "Score", "Risk", "Top Flags"]],
        body: rows,
        startY: yPos,
        styles: {
          fontSize: 8,
        },
        headStyles: {
          fillColor: [37, 99, 235],
          textColor: 255,
        },
        alternateRowStyles: {
          fillColor: [248, 250, 252],
        },
        margin: { left: 32, right: 32 },
        didDrawPage: () => {
          addHeader();
          if (listingHasHigh) addConfidentialWatermark("CONFIDENTIAL");
          else if (hasHighRisk) addConfidentialWatermark("INTERNAL USE ONLY");
          addFooter();
        },
      });
    });
  }

  return doc;
}

/**
 * Generate and download INTERNAL fraud PDF (full flags/explanations)
 */
export async function exportFraudPdfReport(
  data,
  fileName = "fraud_report.pdf"
) {
  const doc = buildFraudPdfDoc(data, "internal");
  const arrayBuffer = doc.output("arraybuffer");
  const blob = new Blob([arrayBuffer], { type: "application/pdf" });
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = fileName;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

/**
 * Generate and download a PUBLIC-SAFE, REDACTED fraud PDF.
 * No flags, no explanations, no CONFIDENTIAL watermark.
 */
export async function exportPublicFraudPdfReport(data, fileName = null) {
  // If filename is null → return ArrayBuffer instead of downloading
  const doc = buildFraudPdfDoc(data, "public");
  const arrayBuffer = doc.output("arraybuffer");

  if (!fileName) {
    return arrayBuffer; // caller handles it
  }

  // Normal download case:
  const blob = new Blob([arrayBuffer], { type: "application/pdf" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = fileName;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);

  return arrayBuffer;
}


/**
 * Generate an encrypted / password-protected INTERNAL fraud PDF.
 */
export async function exportProtectedFraudPdfReport(
  data,
  fileName = "fraud_report_protected.pdf"
) {
  const doc = buildFraudPdfDoc(data, "internal");
  const pdfBytes = doc.output("arraybuffer");

  const userPassword = prompt(
    "Enter a password to encrypt this PDF (do not share publicly):",
    ""
  );
  if (!userPassword) {
    alert("Password not provided. PDF was not generated.");
    return;
  }

  const encryptedBytes = await encryptPdf(pdfBytes, {
    userPassword,
    ownerPassword: userPassword,
  });

  downloadEncryptedPdf(fileName, encryptedBytes);
}
